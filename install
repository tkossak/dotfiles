#!/usr/bin/env bash

# TODO: check return codes everywhere
# TODO: create functions: LOG_ERROR, LOG_INFO
# TODO: add youtube-dl -U
# TODO: fzf - cancel interactive script! provide Y
# TODO: change aptget: use apt-cache to check if it's updated or older version. If older, then update it.
# NEW OPTIONS
#    -u :: update
#    -oc -ol -oh -ow

set -o errexit
set -o pipefail
set -o nounset
# set -o xtrace

# Set magic variables for current file & dir
# __dir="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
# __file="${__dir}/$(basename "${BASH_SOURCE[0]}")"
# __base="$(basename ${__file} .sh)"
# __root="$(cd "$(dirname "${__dir}")" && pwd)"

# magic variables for links
__file="$(readlink -f ${BASH_SOURCE[0]})"
__dir="$(cd "$(dirname "${__file}")" && pwd)"

# arg1="${1:-}"
# ================================================================================
# UPDATE GLOBAL VARS


__myos="$(uname -s)"
__myhost="$(uname -n)"
            case ${__myos} in
                CYGWIN*)
                    __myos="CYGWIN"
                    if [[ ${__myhost} = AWA* ]]; then
                        __myhost="W"
                    elif [[ ${__myhost} = HEAVEN ]]; then
                        __myhost="H"
                    else
                        __myhost="OTHER"
                    fi
                    ;;
                Linux)
                    __myos="LINUX"
                    if [[ ${__myhost} = LMQ ]]; then
                        __myhost="H"
                    else
                        __myhost="OTHER"
                    fi
                    ;;
                *)
                    __myos="OTHER"
                    __myhost="OTHER"
                    ;;
            esac
__dir_dlocal="$(cd "$(dirname "${__dir}")" && pwd)/dotfiles.local"
__dir_dlocal="$(readlink -f ${__dir_dlocal})"
hash cygpath 2>/dev/null \
    && __win_appdata="$(cygpath -au ${APPDATA:-})" || __win_appdata=""
hash sudo 2>/dev/null \
    && __sudo="sudo" \
    || __sudo=""

# aptget install cmd:
__aptget_install_cmd=""
if hash apt-get 2>/dev/null; then
    __aptget_install_cmd="${__sudo} apt-get install -qyf"
fi

__logi_errors=()
__logi_info=()

if hash curl 2>/dev/null; then
    __geturl_app="curl -fL -o"
elif hash wget 2>/dev/null; then
    __geturl_app="wget -O"
else
    loguj -e -t "---" "curl/wget not present"
fi

# ================================================================================
# Initial cmds:

mkdir -p ~/apps
mkdir -p ~/.emacs.d/mine
# mkdir -p ~/.emacs.d/evil
[[ -d ${__win_appdata} ]] &&
    mkdir -p ${__win_appdata}/.emacs.d/mine
find ${__dir}/bin -type f -not -name 'create_bash.model' -exec chmod +x {} \;
find ${__dir} -maxdepth 1 -type f -not -name 'install' -exec chmod -x {} \;


# --------------------------------------------------------------------------------
# --------------------------------------------------------------------------------
# --------------------------------------------------------------------------------
# checksum() <FILE> <OPTIONS>
# return 0 if sum is ok
# OPTIONS:
#   -sha1 <SHA1SUM>  :: check the <FILE> against this sha1sum
# RETURN VALUES
#    1 = wrong SUM!
# <> 1 = other errors
checksum()
{
    local file=""
    local sum_type
    local sum_value
    local ltype="SUM"
    while [[ $# > 0 ]]; do
        case "$1" in
            -sha1) # sum type
                shift
                sum_value="$1"
                sum_type="sha1"
                shift
                ;;
            *) # file name to check
                if [[ -n "${file}" ]]; then
                    loguj -e -t "${ltype}" "Unknown option? ($1)"
                    return 3
                fi

                file="$1"
                shift

                if [[ ! -r "${file}" ]]; then
                    loguj -e -t "${ltype}" "Can't read file: ${file}"
                    return 2
                fi
                ;;
        esac
    done

    # CHECK SUM:
    case "${sum_type}" in
        sha1)
            sha1sum --status -c <(echo "${sum_value}" "${file}") \
                ||
                {
                    loguj -e -t "${ltype}" "WRONG CHECKSUM for: ${file}"
                    return 1
                } \
                &&
                {
                    loguj -p -i -t "${ltype}" "Checksum ok: ${file}"
                    return 0
                }
            ;;
        *)
            loguj -e -t "${ltype}" "Unknown sum type: ${sum_type}"
            return 4
            ;;
    esac
}


# --------------------------------------------------------------------------------
# --------------------------------------------------------------------------------
# --------------------------------------------------------------------------------
# create_link [OPTIONS] <SRC_FILE> <DST_LINK>
# OPTIONS:
#    -w  :: create windows hard link (otherwise it's linux soft link)
#    -c  :: cp instead of creating link
#    -b  :: backup old file/dir (otherwise just remove it)
# $1 = source file
# $2 = destination = link path/link
create_link()
{
    local link_type="LINUX"
    local if_backup="N"
    local src_file=""
    local dst_link=""
    local ltype="LNK"

    while [[ $# > 0 ]]; do
        case $1 in
            -w) link_type="WIN HARD"
                shift
                ;;
            -c) link_type="CP"
                shift
                ;;
            -b) if_backup="Y"
                shift
                ;;
            *) # SRC_FILE + DST_LINK
                if [[ -z "${src_file}" ]]; then
                    src_file="$1"
                elif [[ -z "${dst_link}" ]]; then
                    dst_link="$1"
                else
                    loguj -e -t "${ltype}" "Unknown option? ($1)"
                    return 3
                fi
                shift
                ;;
        esac
    done

    # check if src exists:
    if [[ ! -e "${src_file}" ]]; then
        loguj -e -t "${ltype}" "Src file ${src_file} does not exists."
        return 1
    fi
    src_file="$(readlink -f ${src_file})"

    # check if parent directory of dst exists:
    if [[ ! -d "$(cd "$(dirname "${dst_link}")" && pwd)" ]]; then
        loguj -e -t "${ltype}" "Parent directory of ${dst_link} does not exists."
        return 1
    fi

    # dst_link="$(readlink -f ${dst_link})"

    # remove dst if it's a link
    if [[ -L "${dst_link}" ]]; then
        rm "${dst_link}"
    fi

    # backup dst
    if [[ -f ${dst_link} && ! -L ${dst_link} ]]; then
        if [[ ${if_backup} = "Y" ]]; then
            local backup_file="${dst_link}.old"
            if [[ -e ${backup_file} ]]; then
                loguj -p -i -t "${ltype}" "NOT doing backup, it already exists (${backup_file})"
                rm -rf "${dst_link}"
            else
                loguj -p -i -t "${ltype}" "Backup ${backup_file}"
                mv "${dst_link}" "${backup_file}"
            fi
        else
            rm -rf "${dst_link}"
        fi
    fi

    # linking:
    if [[ $link_type = "WIN HARD" ]]; then
        loguj -p -i -t "${ltype}" "LINK Windows ---${dst_link}--- to ---${src_file}---... "
        if [[ -d ${src_file} ]]; then
            cmd /c mklink /J "$(cygpath -aw ${dst_link})" "$(cygpath -aw ${src_file})"
        else
            cmd /c mklink /H "$(cygpath -aw ${dst_link})" "$(cygpath -aw ${src_file})"
        fi
        loguj -l -t "${ltype}" "WIN HARD $(basename ${dst_link} .sh)"
    elif [[ $link_type = "CP" ]]; then
        # loguj -p -i -t "${ltype}" "COPY ${dst_link} ---to--- ${src_file} ---... "
        loguj -l -t "${ltype}" "CP $(basename ${dst_link} .sh)"
        cp "${src_file}" "${dst_link}"
    elif [[ $link_type = "LINUX" ]]; then
        # loguj -p -i -t "${ltype}" "Linux ${dst_link} ---to--- ${src_file} ---... "
        loguj -l -t "${ltype}" "Linux $(basename ${dst_link} .sh)"
        ln -s "${src_file}" "${dst_link}"
    else
        loguj -e -t "${ltype}" "bledny link_type: ${link_type}"
        return 99
    fi ||
        {
            loguj -e -t "${ltype}" "$(basename ${dst_link} .sh)"
            return 99
        }

}


# --------------------------------------------------------------------------------
# --------------------------------------------------------------------------------
# --------------------------------------------------------------------------------
# loguj [OPTIONS] <MSG>
# log format
# [TAG][TYPE][MSG]
# OPTIONS
#   -i  :: info
#   -s  :: info installed (default)
#   -l  :: info linked
#   -c  :: info cloned
#   -d  :: info downloaded
#   -ss :: section start
#   -se :: section end
#   -e  :: err
#   -w  :: warn
#   -p  :: print only (do not add to arrays)
#   -t <TAG> ::
# __logi_errors=()
# __logi_info=()
loguj()
{
    local ltag=" ? "
    local ltype="INFO_INSTALLED"
    local lmsg=""
    local lprefix="==="
    local ltmp=""
    local if_print_only="N"

    while [[ $# > 0 ]]; do
        case $1 in
            -i)
                ltype="INFO"
                shift
                ;;
            -s)
                ltype="INFO_INSTALLED"
                shift
                ;;
            -l)
                ltype="INFO_LINKED"
                shift
                ;;
            -c)
                ltype="INFO_CLONED"
                shift
                ;;
            -d)
                ltype="INFO_DOWNLOADED"
                shift
                ;;
            -ss)
                ltype="SEC_START"
                shift
                ;;
            -se)
                ltype="SEC_END"
                shift
                ;;

            -e) ltype="ERROR"
                shift
                ;;
            -w) ltype="WARN"
                shift
                ;;
            -t) shift
                ltag="$1"
                shift
                ;;
            -p) shift
                if_print_only="Y"
                ;;
            *)
                if [[ -z "${lmsg}" ]]; then
                    lmsg="$1"
                    shift
                else
                    echo "===[LOG][ERR ]: Unknown option? ($1)"
                    __logi_info+=("[LOG][ERR ]: Unknown option? ($1)")
                    __logi_errors+=("[LOG][ERR ]: Unknown option? ($1)")
                    return 99
                fi
            ;;
        esac
    done

    if [[ "${ltype}" = "INFO" ]]; then
        ltmp="${lprefix}[${ltag}][INFO]: ${lmsg}"
        echo  "${ltmp}"
        [[ "${if_print_only}" = "N" ]] && __logi_info+=("${ltmp}")
    elif [[ "${ltype}" = "INFO_INSTALLED" ]]; then
        ltmp="${lprefix}[${ltag}][INFO]: INSTALLED: ${lmsg} "
        echo "${ltmp}"
        [[ "${if_print_only}" = "N" ]] && __logi_info+=("${ltmp}")
    elif [[ "${ltype}" = "INFO_LINKED" ]]; then
        ltmp="${lprefix}[${ltag}][INFO]: LINKED: ${lmsg} "
        echo "${ltmp}"
        [[ "${if_print_only}" = "N" ]] && __logi_info+=("${ltmp}")
    elif [[ "${ltype}" = "INFO_CLONED" ]]; then
        ltmp="${lprefix}[${ltag}][INFO]: CLONED: ${lmsg} "
        echo "${ltmp}"
        [[ "${if_print_only}" = "N" ]] && __logi_info+=("${ltmp}")
    elif [[ "${ltype}" = "INFO_DOWNLOADED" ]]; then
        ltmp="${lprefix}[${ltag}][INFO]: DOWNLOADED: ${lmsg} "
        echo "${ltmp}"
        [[ "${if_print_only}" = "N" ]] && __logi_info+=("${ltmp}")
    elif [[ "${ltype}" = "SEC_START" ]]; then
        ltmp="${lprefix}[${ltag}][INFO]: ==========<<< START: ${lmsg} >>>=========="
        echo "${ltmp}"
        [[ "${if_print_only}" = "N" ]] && __logi_info+=("${ltmp}")
    elif [[ "${ltype}" = "SEC_END" ]]; then
        ltmp="${lprefix}[${ltag}][INFO]: ==========<<< END: ${lmsg} >>>=========="
        echo "${ltmp}"
        [[ "${if_print_only}" = "N" ]] && __logi_info+=("${ltmp}")
    elif [[ "${ltype}" = "ERROR" || "${ltype}" = "WARN" ]]; then
        ltmp="${lprefix}[${ltag}][WARN]: ${lmsg}"
        echo "${ltmp}"
        [[ "${if_print_only}" = "N" ]] &&
            {
                __logi_info+=("${ltmp}")
                __logi_errors+=("${ltmp}")
            }
    else
                __logi_info+=("wrong ltype=${ltype}")
                __logi_errors+=("wrong ltype=${ltype}")
                return 99
    fi
}


# --------------------------------------------------------------------------------
# --------------------------------------------------------------------------------
# --------------------------------------------------------------------------------
# aptget <APP_INSTALL> <APP_RUN>
# $1 = app name to install (passed to apt-get)
# $2 = app name to check if it's installed already
aptget()
{
    local app_install="${1:?Error: app name not set}"
    local app_run="${2:-${1}}"
    local ltype="APT"

    # check if app is installed
    if hash ${app_run} 2>/dev/null; then
        loguj -i -t "${ltype}" "Already installed: ${app_run}"
        return 0
    fi

    # build instal command
    # add sudo
    # instal_cmd="${instal_cmd}sudo "

    # add apt-get
    if [[ -z "${__aptget_install_cmd}" ]]; then
        loguj -e -t "${ltype}" "No apt-get tool (${app_install})"
        return 1
    fi

    local install_cmd="${__aptget_install_cmd} ${app_install}"
    loguj -p -i -t "${ltype}" "Installing: ${app_run}"
    ${install_cmd} \
        ||
        {
            loguj -e -t "${ltype}" "During installation of ${app_install}"
            return 1

        } \
        &&
        {
            loguj -s -t "${ltype}" "${app_run}"
        }
}


# --------------------------------------------------------------------------------
# --------------------------------------------------------------------------------
# --------------------------------------------------------------------------------
# gitclone
# $1  = git url to clone
# $2  = git folder to clone to
# $3- = script to run after cloning
gitclone()
{
    local giturl="${1:?Error: Git url not set}"
    local gitfolder="${2:?Error: Git folder not set}"
    shift
    shift
    local runlater=("$@")
    local ltype="GIT"

    if [[ -d ${gitfolder} ]]; then
        loguj -i -t "${ltype}" "Already exists: $(basename ${gitfolder} .sh)"
        return 0
    fi
    loguj -p -i -t "${ltype}" "Cloning ${giturl} ===TO=== ${gitfolder}"
    git clone "${giturl}" "${gitfolder}" ||
        {
            loguj -e -t "${ltype}" "Error while clongin ${giturl} ===TO=== ${gitfolder}"
            return 1
        }

    cd ${gitfolder}
    for run in "${runlater[@]:-}" ; do
        loguj -i -t "${ltype}" "Run: ${run}"
        ${run}
    done \
        ||
        {
            loguj -e -t "${ltype}" "Run: ${run} ===APP:=== ${giturl}"
            return 1
        }

}


# --------------------------------------------------------------------------------
# --------------------------------------------------------------------------------
# --------------------------------------------------------------------------------
# geturl [OPTIONS] <URL> <FILE> [OPTIONS] [RUN_LATER_CMDS]
# OPTIONS:
#     -u  :: update (delete the file/folder and redownload it)
#     -d  :: delete the file bofore downloading and after succussful install
#     -sha1 <SUM> :: sha1sum of the file to check. If it fails, file is not installed
geturl()
{
    local ltype="URL"
    local update=""
    local url=""
    local file=""
    local sum_type=""  # for checksum()
    local sum_value="" # for checksum()
    local if_moved_to_tmpfile=0
    local if_del=0

    while [[ $# > 0 ]]; do
        case "$1" in
            -u)
                shift
                update="Y"
                ;;
            -d)
                shift
                if_del=1
                ;;
            -sha1)
                shift
                sum_value="${1}"
                sum_type="sha1"
                shift
                ;;
            *)
                if [[ -z "${url}" ]]; then
                    url="${1}"
                elif [[ -z "${file}" ]]; then
                    file="${1}"
                else
                    loguj -e -t "${ltype}" "Unknown option? ($1)"
                    return 3
                fi
                shift
                ;;
        esac
    done

    if [[ ${if_del} = 1 ]]; then
        rm -rf "${file}"
    fi

    local runlater=("$@")
    tmpfile="${file}#.#"

    if [[ -z "${__geturl_app}" ]]; then
        loguj -e -t "${ltype}" "No curl/wget app. (${url})"
        return 99
    fi


    # [[ ! -z "${file}" ]] && file="-o ${file}"

    if [[ "${update}" = "Y" && -e ${file} ]]; then
        mv "${file}" "${tmpfile}"
        if_moved_to_tmpfile=1
    elif [[ -e ${file} ]]; then
        loguj -i -t "${ltype}" "File already exists: $(basename ${file} .sh). Not redownloading." 
        return 0
    fi

    # download:
    loguj -p -i -t "${ltype}" "Downloading ${url}"
    ${__geturl_app} ${file} ${url} \
        ||
        {
            loguj -e -t "${ltype}" "Downloading: ${url}"
            if [[ ${if_moved_to_tmpfile} = 1 ]]; then
                mv -f ${tmpfile} ${file} \
                    && loguj -p -i -t "${ltype}" "Old file restored: ${tmpfile}" \
                    || loguj -e -t "${ltype}" "Restoring old file: ${tmpfile}"

            fi
            return 1
        }

    # check sum:
    if [[ -n ${sum_type} ]]; then
        checksum ${file} -${sum_type} ${sum_value} ||
            {
                # error displayed by the checksum function
                if [[ ${if_moved_to_tmpfile} = 1 ]]; then
                    mv -f ${tmpfile} ${file} \
                        && loguj -p -i -t "${ltype}" "Old file restored: ${tmpfile}" \
                        || loguj -e -t "${ltype}" "Restoring old file: ${tmpfile}"
                fi
                return 1
            }
    fi

    loguj -d -t "${ltype}" "${file}"
    if [[ ${if_moved_to_tmpfile}=1 && -e ${tmpfile} ]]; then
        rm -rf "${tmpfile}"
    fi

    cd "$(cd "$(dirname "${file}")" && pwd)"
    for run in "${runlater[@]:-}" ; do
        loguj -i -t "${ltype}" "Run: ${run}"
        ${run}
    done \
        ||
        {
            loguj -e -t "${ltype}" "Run: ${run} ===APP:=== ${url}"
            return 1
        }


    if [[ ${if_del} = 1 ]]; then
        rm -rf "${file}"
    fi
}


# --------------------------------------------------------------------------------
# --------------------------------------------------------------------------------
# --------------------------------------------------------------------------------
# pipinstall [OPTIONS] <APP_INSTALL>
# OPTIONS:
#   -2  :: pip2
#   -3  :: pip3
#   -u  :: update
# $1 = app name to install
pipinstall()
{
    local ltype="PIP"
    local pip="pip"
    local update=""
    local cmdinstall=""
    while [[ $# > 0 ]]; do
        case "$1" in
            -2)
                shift
                pip="pip2"
                ;;
            -3)
                shift
                pip="pip3"
                ;;
            -u)
                shift
                update="-U"
                ;;
            *)
                if [[ -z "${cmdinstall}" ]]; then
                    cmdinstall="${1}"
                else
                    loguj -e -t "${ltype}" "Unknown option? ($1)"
                    return 3
                fi
                shift
                ;;
        esac
    done

    if ${pip} -q show ${cmdinstall}; then # app is installed
        if [[ -z "${update}" ]]; then
            loguj -i -t "${ltype}" "App already installed: ${cmdinstall}"
            return 0
        fi
    fi
    loguj -p -i -t "${ltype}" "installing ${cmdinstall}..."
    ${__sudo} ${pip} install ${update} ${cmdinstall} \
        &&
        {
            loguj -l -t "${ltype}" "${cmdinstall}"
        } \
        ||
        {
            loguj -e -t "${ltype}" "Installing: ${__sudo} ${pip} install ${update} ${cmdinstall}"
            return 1
        }
}


# --------------------------------------------------------------------------------
# --------------------------------------------------------------------------------
# --------------------------------------------------------------------------------
# break_links()
break_links()
{
    local ltype="BRK"
    loguj -ss -t "${ltype}" "BREAKING LINKS"
    for link in ~/.tmux.conf ~/.vimrc ~/.vimrc.local ~/.bashrc ~/.bashrc.local ~/.emacs ~/.emacs.d/mine/.emacs.local ~/.gitconfig ~/.gitconfig.local ~/.config/ranger/rc.conf ~/.config/ranger/rifle.conf ~/.mplayer/config ~/.mplayer/input.conf ~/.weechat; do
        if [[ ! -e "$link" ]]; then
            loguj -i -t "${ltype}" "File does not exist: $link"
        elif [[ -L "$link" ]]; then
            cp --remove-destination "$(readlink ${link})" ${link}
            loguj -i -t "${ltype}" "UNLINKED: ${link}"
        else
            loguj -i -t "${ltype}" "Not a link: ${link}"
        fi
    done
    loguj -se -t "${ltype}" "BREAKING LINKS"
}


# --------------------------------------------------------------------------------
# --------------------------------------------------------------------------------
# --------------------------------------------------------------------------------
# install_dotfiles
install_dotfiles()
{
    local ltype="DOT"
    loguj -ss -t "${ltype}" "DOTFILES"

    # Folders:
    create_link ${__dir} ~/.dotfiles
    [[ -d ${__dir_dlocal} ]] && create_link ${__dir_dlocal} ~/.dotfiles.local
    [[ -d ${__dir_dlocal} ]] && chmod -x ${__dir_dlocal}/*

    # TMUX
    create_link ${__dir}/tmux.conf ~/.tmux.conf

    # Git
    create_link ${__dir}/gitconfig ~/.gitconfig
    [[ -d ${__dir_dlocal} ]] && create_link ${__dir_dlocal}/gitconfig.local ~/.gitconfig.local

    # Bash:
    create_link ${__dir}/bashrc ~/.bashrc
    [[ -d ${__dir_dlocal} ]] && create_link ${__dir_dlocal}/bashrc.local ~/.bashrc.local


    # Vim
    create_link ${__dir}/vimrc ~/.vimrc
    [[ -d ${__dir_dlocal} ]] && create_link ${__dir_dlocal}/vimrc.local ~/.vimrc.local

    # Emacs Linux:
    if hash emacs 2>/dev/null; then
        create_link ${__dir}/emacs ~/.emacs
        [[ -d ${__dir_dlocal} ]] && create_link ${__dir_dlocal}/emacs.local ~/.emacs.d/mine/.emacs.local
    fi

    # Emacs Win:
    if [[ -d ${__win_appdata} ]]; then
        create_link -w ${__dir}/emacs ${__win_appdata}/.emacs
        [[ -d ${__dir_dlocal} ]] && create_link -w ${__dir_dlocal}/emacs.local ${__win_appdata}/.emacs.d/mine/.emacs.local
        # evil-leader:
        create_link -w ~/.emacs.d/mine/evil-leader.el ${__win_appdata}/.emacs.d/mine/evil-leader.el
        # key-chord:
        create_link -w ~/.emacs.d/mine/key-chord.el ${__win_appdata}/.emacs.d/mine/key-chord.el
        # evil:
        create_link -w ~/.emacs.d/evil ${__win_appdata}/.emacs.d/evil
        # org-mode:
        create_link -w ~/.emacs.d/org-mode ${__win_appdata}/.emacs.d/org-mode
    fi

    # Emacs local files Linux + Win
    if [[ -d ${__dir_dlocal} ]]; then
        create_link ${__dir_dlocal} ~/.dotfiles.local
        create_link ${__dir_dlocal}/bashrc.local ~/.bashrc.local
        create_link ${__dir_dlocal}/vimrc.local ~/.vimrc.local
        create_link ${__dir_dlocal}/gitconfig.local ~/.gitconfig.local
        create_link ${__dir_dlocal}/emacs.local ~/.emacs.d/mine/.emacs.local
        [[ -d ${__win_appdata} ]] && create_link -w ${__dir_dlocal}/emacs.local ${__win_appdata}/.emacs.d/mine/.emacs.local
    else
        loguj -i -t "${ltype}" "Emacs: no local dir."
    fi

    #Ranger:
    # if hash ranger 2>/dev/null; then
    #     sed -i 's/^set column_ratios 1,5,3$/set column_ratios 1,3,4' ~/.config/ranger/rc.conf
    # fi
    if hash ranger 2>/dev/null; then
        find ~/.config/ranger -type f -not -name 'bookmarks' -not -name 'history' -not -name 'tagged' -exec rm -rf {} \;
        ranger --copy-config=all
        sed -i 's/^set column_ratios 1,3,4$/set column_ratios 1,5,3/;
        s/^set show_hidden false$/set show_hidden true/;
        s/^set preview_files true$/set preview_files false/
        s/^set preview_files true$/set preview_files false/
        s/^set preview_directories true$/set preview_directories false/' ~/.config/ranger/rc.conf


        if [[ -d "${__dir_dlocal}" ]]; then
            case ${__myos} in
                CYGWIN)
                    if [[ ${__myhost} = W ]]; then
                        # create_link ~/.dotfiles.local/rifle.conf.w.cygwin ~/.config/ranger/rifle.conf
                        cat ~/.config/ranger/rifle.conf ${__dir_dlocal}/rifle.conf.w.cygwin > ~/.config/ranger/rifletmp.conf
                        mv ~/.config/ranger/rifletmp.conf ~/.config/ranger/rifle.conf
                    elif [[ ${__myhost} = H ]]; then
                        # create_link ~/.dotfiles.local/rifle.conf.h.cygwin ~/.config/ranger/rifle.conf
                        cat ~/.config/ranger/rifle.conf ${__dir_dlocal}/rifle.conf.h.cygwin > ~/.config/ranger/rifletmp.conf
                        mv ~/.config/ranger/rifletmp.conf ~/.config/ranger/rifle.conf
                    else
                        loguj -i -t "${ltype}" "Ranger - cygwin - unknown host Copying default file."
                        cat ~/.config/ranger/rifle.conf ${__dir}/rifle.conf > ~/.config/ranger/rifletmp.conf
                        mv ~/.config/ranger/rifletmp.conf ~/.config/ranger/rifle.conf
                    fi
                    ;;
                LINUX)
                    if [[ ${__myhost} = H ]]; then
                        # create_link ~/.dotfiles.local/rifle.conf.h.linux ~/.config/ranger/rifle.conf
                        cat ~/.config/ranger/rifle.conf ${__dir_dlocal}/rifle.conf.h.linux > ~/.config/ranger/rifletmp.conf
                        mv ~/.config/ranger/rifletmp.conf ~/.config/ranger/rifle.conf
                    else
                        loguj -i -t "${ltype}" "Ranger - linux - unknown host Copying default file."
                        cat ~/.config/ranger/rifle.conf ${__dir}/rifle.conf > ~/.config/ranger/rifletmp.conf
                        mv ~/.config/ranger/rifletmp.conf ~/.config/ranger/rifle.conf
                    fi
                    ;;
                *)
                    loguj -i -t "${ltype}" "Ranger - unknown os. Copying default file."
                    cat ~/.config/ranger/rifle.conf ${__dir}/rifle.conf > ~/.config/ranger/rifletmp.conf
                    mv ~/.config/ranger/rifletmp.conf ~/.config/ranger/rifle.conf
                    ;;
            esac
        else
            loguj -i -t "${ltype}" "Ranger - no local dotfiles. Copying default file."
            cat ~/.config/ranger/rifle.conf ${__dir}/rifle.conf > ~/.config/ranger/rifletmp.conf
            mv ~/.config/ranger/rifletmp.conf ~/.config/ranger/rifle.conf
        fi
    else
        loguj -i -t "${ltype}" "Ranger not found. Not creating links."
    fi

    # mplayer
    if hash mplayer 2>/dev/null || [[ -d ~/.mplayer ]]; then
        create_link ${__dir}/mplayer_config ~/.mplayer/config
        create_link ${__dir}/mplayer_input.conf ~/.mplayer/input.conf
    fi

    # weechat
    if ( hash weechat 2>/dev/null || [[ -d ~/.weechat ]] ) && [[ -d ${__dir_dlocal} ]]; then
        if [[ -d ${__dir_dlocal}/.weechat ]]; then
            create_link ${__dir_dlocal}/.weechat ~/.weechat
        else
            loguj -i -t "${ltype}" "No weechat local dotfiles."
        fi
    fi

    vim +PluginInstall +PluginClean +qall

    loguj -se -t "${ltype}" "DOTFILES"
}


# --------------------------------------------------------------------------------
# --------------------------------------------------------------------------------
# --------------------------------------------------------------------------------
install_apps_basic3_new_comp()
{

    local ltype="BA3"
    loguj -ss -t "${ltype}" "BASICS 3"

    # Emacs
    aptget emacs || true
    if hash emacs 2>/dev/null; then
        # evil-leader:
        geturl https://raw.githubusercontent.com/cofi/evil-leader/master/evil-leader.el ~/.emacs.d/mine/evil-leader.el -sha1 00c336e55307dbcb3f73f47b1d9a1d759404341d || true
        # key-chord:
        geturl http://www.emacswiki.org/emacs/download/key-chord.el ~/.emacs.d/mine/key-chord.el -sha1 2da61bf970ca332c4de96c1977fc7e326df6c33a || true
        # evil:
        gitclone https://gitorious.org/evil/evil.git ~/.emacs.d/evil \
            ||
            {
                loguj -i -t "${ltype}" "Manually downloading evil.git"
                rm -rf ~/.emacs.d/evil
                rm -rf ~/.emacs.d/lyro-evil*
                cd ~/.emacs.d
                if [[ ! -f evil-default.zip ]]; then
                    ${__geturl_app} evil-default.zip https://bitbucket.org/lyro/evil/get/default.zip \
                        ||
                        {
                            loguj -e -t "${ltype}" "Downloading evil.git (default.zip)"
                        } \
                        &&
                        {
                            unzip evil-default.zip
                            mv ~/.emacs.d/lyro-evil* evil
                            rm ~/.emacs.d/evil-default.zip
                            loguj -d -t "${ltype}" "evil"
                            loguj -e -t "${ltype}" "Evil downloaded manually."
                        }
                fi
            }
        # org-mode:
        gitclone git://orgmode.org/org-mode.git ~/.emacs.d/org-mode "git checkout -b stable origin/maint" "git pull" "make autoloads" || true
    fi

    # geeknote
    gitclone https://github.com/VitaliyRodnenko/geeknote.git ~/apps/geeknote "${__sudo} python setup.py install" "geeknote settings --editor vim" || true

    # Reszta BASICS 3:
    pipinstall -3 BeautifulSoup4

    # flake8
    pipinstall -3 flake8

    # bashate
    pipinstall -3 bashate

    # httpie
    pipinstall httpie

    # geeknote login....?
    loguj -se -t "${ltype}" "BASICS 3"
}


# --------------------------------------------------------------------------------
# --------------------------------------------------------------------------------
# --------------------------------------------------------------------------------
# install_apps_basics2
install_apps_basics2()
{

    local ltype="BA2"
    loguj -ss -t "${ltype}" "BASICS 2"

    # commacd
    geturl https://raw.githubusercontent.com/shyiko/commacd/master/commacd.bash ~/.commacd.bash || true

    # glances
    aptget glances \
        &&
        {
            aptget lm-sensors || true
            pipinstall -2 PySensors
        } || true

    # speedtest-cli
    pipinstall -2 speedtest-cli

    # fzf - asks questions
    if [[ ! -d ~/.fzf ]]; then
        git clone --depth 1 https://github.com/junegunn/fzf.git ~/.fzf && ~/.fzf/install
    fi

    # geeknote login
    loguj -se -t "${ltype}" "BASICS 2"
}

# --------------------------------------------------------------------------------
# --------------------------------------------------------------------------------
# --------------------------------------------------------------------------------
# install_apps_basic
install_apps_basic()
{

    local ltype="BA1"
    loguj -ss -t "${ltype}" "BASICS 1"

    # update repositories
    # if hash apt-get 2>/dev/null; then
    #     ${__sudo} apt-get update
    # fi

    # Basic
    # git
    aptget git || true

    # vim
    aptget vim || true

    # make
    aptget make || true

    # vim-vundle
    gitclone https://github.com/gmarik/Vundle.vim.git ~/.vim/bundle/Vundle.vim || true

    # PIP2
    if hash python2 2>/dev/null; then
        aptget python-pip pip \
            ||
            {
                geturl https://bootstrap.pypa.io/get-pip.py /tmp/get-pip.py -sha1 89eb61fc5b59f14df7f0aa7b020afb5a6ded2e14 "sudo python2 get-pip.py" "rm get-pip.py"
            }
    fi

    # PIP3
    if hash python3 2>/dev/null; then
        aptget python3-pip pip3 \
            ||
            {
                geturl https://bootstrap.pypa.io/get-pip.py /tmp/get-pip.py -sha1 89eb61fc5b59f14df7f0aa7b020afb5a6ded2e14 "sudo python3 get-pip.py" "rm get-pip.py"
            }
    fi

    # Ranger
    # rm -rf ~/apps/ranger ~/.config/ranger
    gitclone https://github.com/hut/ranger.git ~/apps/ranger "${__sudo} make install" "ranger --copy-config=all" || true

    # TMUX
    aptget tmux || true

    # wget
    aptget wget && __geturl_app="wget -O" || true

    # curl
    aptget curl && __geturl_app="curl -o" || true

    # dtrx
    aptget dtrx ||
        {
            rm -rf /tmp/dtrx-7.1
            geturl -d http://brettcsmith.org/2007/dtrx/dtrx-7.1.tar.gz /tmp/dtrx-7.1.tar.gz -sha1 05cfe705a04a8b84571b0a5647cd2648720791a4 "tar -xf dtrx-7.1.tar.gz" "cd dtrx-7.1" "${__sudo} python setup.py install --prefix=/usr/local" "rm -rf /tmp/dtrx-7.1" "rm -rf /tmp/dtrx-7.1.tar.gz"
        }

    # fasd
    gitclone https://github.com/clvv/fasd.git ~/apps/fasd "${__sudo} make install" || true

    loguj -se -t "${ltype}" "BASICS 1"
}


# --------------------------------------------------------------------------------
# --------------------------------------------------------------------------------
# --------------------------------------------------------------------------------

if_dotfiles="N"
if_basics1="N"
if_basics2="N"
if_basics3_new_comp="N"
if_break_links="N"
ltype="---"

[[ $# = 0 ]] && if_dotfiles="Y"

while [[ $# > 0 ]]; do
    case "$1" in

        -h|--help)
            echo "CLI options:"
            echo "  -l  :: break links"
            echo "  -d  :: install dotfiles"
            echo "  -b  :: install dotfiles + basics 1"
            echo "  -a  :: install dotfiles + basics 1 + 2"
            echo "  -A  :: install dotfiles + basics 1 + 2 + 3 (new comp)"
            exit 0
            ;;

        -l)
            shift
            if_break_links="Y"
            ;;

        -d)
            shift
            if_dotfiles="Y"
            ;;

        -b)
            shift
            if_break_links="Y"
            if_basics1="Y"
            if_dotfiles="Y"
            ;;

        -a)
            shift
            if_break_links="Y"
            if_basics1="Y"
            if_basics2="Y"
            if_dotfiles="Y"
            ;;

        -A)
            shift
            if_break_links="Y"
            if_basics1="Y"
            if_basics2="Y"
            if_basics3_new_comp="Y"
            if_dotfiles="Y"
            ;;

        *)
            loguj -e -t "${ltype}" "Unknown option: $1"
            exit 1
            ;;
    esac
done

# start
# loguj -l -t CLI "testowy log"
# exit
# end

[[ ${if_break_links} = "Y" ]] && break_links

# update repos?
if [[ ( ${if_basics1} = "Y" || ${if_basics2} = "Y" ) ]] && hash apt-get 2>/dev/null; then
    read -p "Do apt-get update (y/n)? " -n 1 -r
    echo
    if [[ ${REPLY} =~ ^[Yy]$ ]]; then
        ${__sudo} apt-get update
    fi

fi

[[ ${if_basics1} = "Y" ]] && install_apps_basic
[[ ${if_basics2} = "Y" ]] && install_apps_basics2
[[ ${if_basics3_new_comp} = "Y" ]] && install_apps_basics3_new_comp
[[ ${if_dotfiles} = "Y" ]] && install_dotfiles

# display info logs
if [[ ${#__logi_info[@]} > 0 ]]; then
    echo "=== LOG INFO =========================================================================="
    for err in "${__logi_info[@]}"; do
        echo ${err}
    done
else
    echo "== No info logs?"
fi

# display ERROR logs
if [[ ${#__logi_errors[@]} > 0 ]]; then
    echo "=== LOG ERRORS =========================================================================="
    for err in "${__logi_errors[@]}"; do
        echo ${err}
    done
else
    echo "=== No Errors."
fi

