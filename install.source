#!/usr/bin/env bash


# --------------------------------------------------------------------------------
# --------------------------------------------------------------------------------
# --------------------------------------------------------------------------------
# loguj [OPTIONS] <MSG>
# log format
# [TAG][TYPE][MSG]
# OPTIONS
#   -i  :: info
#   -s  :: info installed (default)
#   -l  :: info linked
#   -c  :: info cloned
#   -d  :: info downloaded
#   -ss :: section start
#   -se :: section end
#   -e  :: err
#   -w  :: warn
#   -p  :: print only (do not add to arrays)
#   -t <TAG> ::
# __logi_errors=()
# __logi_info=()
loguj()
{
    local ltag=" ? "
    local ltype="INFO_INSTALLED"
    local lmsg=""
    local lprefix="==="
    local ltmp=""
    local if_print_only="N"

    while [[ $# > 0 ]]; do
        case $1 in
            -i)
                ltype="INFO"
                shift
                ;;
            -s)
                ltype="INFO_INSTALLED"
                shift
                ;;
            -l)
                ltype="INFO_LINKED"
                shift
                ;;
            -c)
                ltype="INFO_CLONED"
                shift
                ;;
            -d)
                ltype="INFO_DOWNLOADED"
                shift
                ;;
            -ss)
                ltype="SEC_START"
                shift
                ;;
            -se)
                ltype="SEC_END"
                shift
                ;;

            -e) ltype="ERROR"
                shift
                ;;
            -w) ltype="WARN"
                shift
                ;;
            -t) shift
                ltag="$1"
                shift
                ;;
            -p) shift
                if_print_only="Y"
                ;;
            *)
                if [[ -z "${lmsg}" ]]; then
                    lmsg="$1"
                    shift
                else
                    echo "===[LOG][ERR ]: Unknown option? ($1)"
                    __logi_info+=("[LOG][ERR ]: Unknown option? ($1)")
                    __logi_errors+=("[LOG][ERR ]: Unknown option? ($1)")
                    return 99
                fi
            ;;
        esac
    done

    if [[ "${ltype}" = "INFO" ]]; then
        ltmp="${lprefix}[${ltag}][INFO]: ${lmsg}"
        echo  "${ltmp}"
        [[ "${if_print_only}" = "N" ]] && __logi_info+=("${ltmp}")
    elif [[ "${ltype}" = "INFO_INSTALLED" ]]; then
        ltmp="${lprefix}[${ltag}][INFO]: INSTALLED: ${lmsg} "
        echo "${ltmp}"
        [[ "${if_print_only}" = "N" ]] && __logi_info+=("${ltmp}")
    elif [[ "${ltype}" = "INFO_LINKED" ]]; then
        ltmp="${lprefix}[${ltag}][INFO]: LINKED: ${lmsg} "
        echo "${ltmp}"
        [[ "${if_print_only}" = "N" ]] && __logi_info+=("${ltmp}")
    elif [[ "${ltype}" = "INFO_CLONED" ]]; then
        ltmp="${lprefix}[${ltag}][INFO]: CLONED: ${lmsg} "
        echo "${ltmp}"
        [[ "${if_print_only}" = "N" ]] && __logi_info+=("${ltmp}")
    elif [[ "${ltype}" = "INFO_DOWNLOADED" ]]; then
        ltmp="${lprefix}[${ltag}][INFO]: DOWNLOADED: ${lmsg} "
        echo "${ltmp}"
        [[ "${if_print_only}" = "N" ]] && __logi_info+=("${ltmp}")
    elif [[ "${ltype}" = "SEC_START" ]]; then
        ltmp="${lprefix}[${ltag}]==================<<< START: ${lmsg} >>>=================="
        echo "${ltmp}"
        [[ "${if_print_only}" = "N" ]] && __logi_info+=("${ltmp}")
    elif [[ "${ltype}" = "SEC_END" ]]; then
        ltmp="${lprefix}[${ltag}]==================<<< END: ${lmsg} >>>=================="
        echo "${ltmp}"
        [[ "${if_print_only}" = "N" ]] && __logi_info+=("${ltmp}")
    elif [[ "${ltype}" = "ERROR" || "${ltype}" = "WARN" ]]; then
        ltmp="${lprefix}[${ltag}][WARN]: ${lmsg}"
        echo "${ltmp}"
        [[ "${if_print_only}" = "N" ]] &&
            {
                __logi_info+=("${ltmp}")
                __logi_errors+=("${ltmp}")
            }
    else
                __logi_info+=("wrong ltype=${ltype}")
                __logi_errors+=("wrong ltype=${ltype}")
                return 99
    fi
}



# --------------------------------------------------------------------------------
# --------------------------------------------------------------------------------
# --------------------------------------------------------------------------------
# checksum() <FILE> <OPTIONS>
# return 0 if sum is ok
# OPTIONS:
#   -sha1 <SHA1SUM>  :: check the <FILE> against this sha1sum
# RETURN VALUES
#    1 = wrong SUM!
# <> 1 = other errors
checksum()
{
    local file=""
    local sum_type
    local sum_value
    local ltype="SUM"
    while [[ $# > 0 ]]; do
        case "$1" in
            -sha1) # sum type
                shift
                sum_value="$1"
                sum_type="sha1"
                shift
                ;;
            *) # file name to check
                if [[ -n "${file}" ]]; then
                    loguj -e -t "${ltype}" "Unknown option? ($1)"
                    return 3
                fi

                file="$1"
                shift

                if [[ ! -r "${file}" ]]; then
                    loguj -e -t "${ltype}" "Can't read file: ${file}"
                    return 2
                fi
                ;;
        esac
    done

    # CHECK SUM:
    case "${sum_type}" in
        sha1)
            sha1sum --status -c <(echo "${sum_value}" "${file}") \
                ||
                {
                    loguj -e -t "${ltype}" "WRONG CHECKSUM for: ${file}"
                    return 1
                } \
                &&
                {
                    loguj -p -i -t "${ltype}" "Checksum ok: ${file}"
                    return 0
                }
            ;;
        *)
            loguj -e -t "${ltype}" "Unknown sum type: ${sum_type}"
            return 4
            ;;
    esac
}


# --------------------------------------------------------------------------------
# --------------------------------------------------------------------------------
# --------------------------------------------------------------------------------
# create_link [OPTIONS] <SRC_FILE> <DST_LINK>
# OPTIONS:
#    -w  :: create windows hard link (otherwise it's linux soft link)
#    -c  :: cp instead of creating link
#    -b  :: backup old file/dir (otherwise just remove it)
# $1 = source file
# $2 = destination = link path/link
create_link()
{
    local link_type="LINUX"
    local if_backup="N"
    local src_file=""
    local dst_link=""
    local ltype="LNK"

    while [[ $# > 0 ]]; do
        case $1 in
            -w) link_type="WIN HARD"
                shift
                ;;
            -c) link_type="CP"
                shift
                ;;
            -b) if_backup="Y"
                shift
                ;;
            *) # SRC_FILE + DST_LINK
                if [[ -z "${src_file}" ]]; then
                    src_file="$1"
                elif [[ -z "${dst_link}" ]]; then
                    dst_link="$1"
                else
                    loguj -e -t "${ltype}" "Unknown option? ($1)"
                    return 3
                fi
                shift
                ;;
        esac
    done

    # check if src exists:
    if [[ ! -e "${src_file}" ]]; then
        loguj -e -t "${ltype}" "Src file ${src_file} does not exists."
        return 1
    fi
    src_file="$(readlink -f ${src_file})"

    # check if parent directory of dst exists:
    if [[ ! -d "$(cd "$(dirname "${dst_link}")" && pwd)" ]]; then
        loguj -e -t "${ltype}" "Parent directory of ${dst_link} does not exists."
        return 1
    fi

    # dst_link="$(readlink -f ${dst_link})"

    # remove dst if it's a link
    if [[ -L "${dst_link}" ]]; then
        rm "${dst_link}"
    fi

    # backup dst
    if [[ -e ${dst_link} && ! -L ${dst_link} ]]; then
        if [[ ${if_backup} = "Y" ]]; then
            local backup_file="${dst_link}.old"
            if [[ -e ${backup_file} ]]; then
                loguj -p -i -t "${ltype}" "NOT doing backup, it already exists (${backup_file})"
                rm -rf "${dst_link}"
            else
                loguj -p -i -t "${ltype}" "Backup ${backup_file}"
                mv "${dst_link}" "${backup_file}"
            fi
        else
            rm -rf "${dst_link}"
        fi
    fi

    # linking:
    if [[ $link_type = "WIN HARD" ]]; then
        # loguj -i -t "${ltype}" "LINKED: Win: $(basename ${dst_link} .sh)"
        loguj -l -t "${ltype}" "Win: $(basename ${dst_link} .sh)"
        if [[ -d ${src_file} ]]; then
            cmd /c mklink /J "$(cygpath -aw ${dst_link})" "$(cygpath -aw ${src_file})"
        else
            cmd /c mklink /H "$(cygpath -aw ${dst_link})" "$(cygpath -aw ${src_file})"
        fi
    elif [[ $link_type = "CP" ]]; then
        # loguj -p -i -t "${ltype}" "COPY ${dst_link} ---to--- ${src_file} ---... "
        loguj -i -t "${ltype}" "CP: $(basename ${dst_link} .sh)"
        cp "${src_file}" "${dst_link}"
    elif [[ $link_type = "LINUX" ]]; then
        # loguj -p -i -t "${ltype}" "Linux ${dst_link} ---to--- ${src_file} ---... "
        loguj -l -t "${ltype}" "Lin: $(basename ${dst_link} .sh)"
        ln -s "${src_file}" "${dst_link}"
    else
        loguj -e -t "${ltype}" "bledny link_type: ${link_type}"
        return 99
    fi ||
        {
            loguj -e -t "${ltype}" "$(basename ${dst_link} .sh)"
            return 99
        }

}


# --------------------------------------------------------------------------------
# --------------------------------------------------------------------------------
# --------------------------------------------------------------------------------
# aptget [OPTIONS] <APP_INSTALL> <APP_RUN>
# OPTIONS:
#   -ol :: only linux
#   -oc :: only cygwin
#   -ow :: only host W
#   -oh :: only host H
# $1 = app name to install (passed to apt-get)
# $2 = app name to check if it's installed already
aptget()
{
    local app_install=""
    local app_run=""
    local ltype="APT"
    local not_right=""

    while [[ $# > 0 ]]; do
        case $1 in
            -ol)
                if [[ ${__myos} != "LINUX" ]]; then
                    not_right="Not right os: LINUX != ${__myos}"
                fi
                shift
                ;;
            -oc)
                if [[ ${__myos} != "CYGWIN" ]]; then
                    not_right="Not right os: CYGWIN != ${__myos}"
                fi
                shift
                ;;
            -ow)
                if [[ ${__myhost} != "W" ]]; then
                    not_right="Not right host: W != ${__myhost}"
                fi
                shift
                ;;
            -oh)
                if [[ ${__myhost} != "H" ]]; then
                    not_right="Not right os: H != ${__myhost}"
                fi
                shift
                ;;
            *)
                if [[ -z "${app_install}" ]]; then
                    app_install="$1"
                    shift
                elif [[ -z "${app_run}" ]]; then
                    app_run="$1"
                    shift
                else
                    loguj -e -t "${ltype}" "Unknown option? ($1)"
                    return 99
                fi
                ;;
        esac
    done

    [[ -z "${app_run}" ]] && app_run="${app_install}"

    if [[ -n "${not_right}" ]]; then
        loguj -i -t "${ltype}" "${not_right} (${app_run})"
        return 1
    fi


    # check if app is installed
    if hash ${app_run} 2>/dev/null; then
        loguj -i -t "${ltype}" "Already installed: ${app_run}"
        return 0
    elif [[ -n "${__aptget_check_cmd}" ]] &&  ${__aptget_check_cmd} ${app_install} &> /dev/null; then
        loguj -i -t "${ltype}" "Already installed: ${app_install}"
        return 0
    fi

    # build instal command
    # add sudo
    # instal_cmd="${instal_cmd}sudo "

    # add apt-get
    if [[ -z "${__aptget_install_cmd}" ]]; then
        loguj -e -t "${ltype}" "No apt-get tool (${app_install})"
        return 1
    fi

    local install_cmd="${__aptget_install_cmd} ${app_install}"
    loguj -p -i -t "${ltype}" "Installing: ${app_run}"
    ${install_cmd} \
        ||
        {
            loguj -e -t "${ltype}" "During installation of ${app_install}"
            return 1

        } \
        &&
        {
            loguj -s -t "${ltype}" "${app_run}"
        }
}


# --------------------------------------------------------------------------------
# --------------------------------------------------------------------------------
# --------------------------------------------------------------------------------
# gitclone
# $1  = git url to clone
# $2  = git folder to clone to
# $3- = script to run after cloning
gitclone()
{
    local giturl="${1:?Error: Git url not set}"
    local gitfolder="${2:?Error: Git folder not set}"
    shift
    shift
    local runlater=("$@")
    local ltype="GIT"

    if [[ -d ${gitfolder} ]]; then
        loguj -i -t "${ltype}" "Already exists: $(basename ${gitfolder} .sh)"
        return 0
    fi
    loguj -p -i -t "${ltype}" "Cloning ${giturl} ===TO=== $(basename ${gitfolder} .sh)"
    git clone "${giturl}" "${gitfolder}" ||
        {
            loguj -e -t "${ltype}" "Cloning ${giturl} ===TO=== $(basename ${gitfolder} .sh)"
            return 1
        }

    cd ${gitfolder}
    for run in "${runlater[@]:-}" ; do
        loguj -i -t "${ltype}" "Run: ${run}"
        ${run}
    done \
        ||
        {
            loguj -e -t "${ltype}" "Run: ${run} ===APP:=== ${giturl}"
            return 1
        }

}


# --------------------------------------------------------------------------------
# --------------------------------------------------------------------------------
# --------------------------------------------------------------------------------
# geturl [OPTIONS] <URL> <FILE> [OPTIONS] [RUN_LATER_CMDS]
# OPTIONS:
#     -u  :: update (delete the file/folder and redownload it)
#     -d  :: delete the file bofore downloading and after succussful install
#     -sha1 <SUM> :: sha1sum of the file to check. If it fails, file is not installed
geturl()
{
    local ltype="URL"
    local update=""
    local url=""
    local file=""
    local sum_type=""  # for checksum()
    local sum_value="" # for checksum()
    local if_moved_to_tmpfile=0
    local if_del=0

    while [[ $# > 0 ]]; do
        case "$1" in
            -u)
                shift
                update="Y"
                ;;
            -d)
                shift
                if_del=1
                ;;
            -sha1)
                shift
                sum_value="${1}"
                sum_type="sha1"
                shift
                ;;
            *)
                if [[ -z "${url}" ]]; then
                    url="${1}"
                elif [[ -z "${file}" ]]; then
                    file="${1}"
                else
                    loguj -e -t "${ltype}" "Unknown option? ($1)"
                    return 3
                fi
                shift
                ;;
        esac
    done

    if [[ ${if_del} = 1 ]]; then
        rm -rf "${file}"
    fi

    local runlater=("$@")
    tmpfile="${file}#.#"

    if [[ -z "${__geturl_app}" ]]; then
        loguj -e -t "${ltype}" "No curl/wget app. (${url})"
        return 99
    fi


    # [[ ! -z "${file}" ]] && file="-o ${file}"

    if [[ "${update}" = "Y" && -e ${file} ]]; then
        mv "${file}" "${tmpfile}"
        if_moved_to_tmpfile=1
    elif [[ -e ${file} ]]; then
        loguj -i -t "${ltype}" "File already exists: $(basename ${file} .sh). Not redownloading."
        return 0
    fi

    # download:
    loguj -p -i -t "${ltype}" "Downloading ${url}"
    ${__geturl_app} ${file} ${url} \
        ||
        {
            loguj -e -t "${ltype}" "Downloading: ${url}"
            if [[ ${if_moved_to_tmpfile} = 1 ]]; then
                mv -f ${tmpfile} ${file} \
                    && loguj -p -i -t "${ltype}" "Old file restored: ${tmpfile}" \
                    || loguj -e -t "${ltype}" "Restoring old file: ${tmpfile}"

            fi
            return 1
        }

    # check sum:
    if [[ -n ${sum_type} ]]; then
        checksum ${file} -${sum_type} ${sum_value} ||
            {
                # error displayed by the checksum function
                if [[ ${if_moved_to_tmpfile} = 1 ]]; then
                    mv -f ${tmpfile} ${file} \
                        && loguj -p -i -t "${ltype}" "Old file restored: ${tmpfile}" \
                        || loguj -e -t "${ltype}" "Restoring old file: ${tmpfile}"
                fi
                return 1
            }
    fi

    loguj -d -t "${ltype}" "${file}"
    if [[ ${if_moved_to_tmpfile}=1 && -e ${tmpfile} ]]; then
        rm -rf "${tmpfile}"
    fi

    cd "$(cd "$(dirname "${file}")" && pwd)"
    for run in "${runlater[@]:-}" ; do
        loguj -i -t "${ltype}" "Run: ${run}"
        ${run}
    done \
        ||
        {
            loguj -e -t "${ltype}" "Run: ${run} ===APP:=== ${url}"
            return 1
        }


    if [[ ${if_del} = 1 ]]; then
        rm -rf "${file}"
    fi
}



# --------------------------------------------------------------------------------
# --------------------------------------------------------------------------------
# --------------------------------------------------------------------------------
# pipinstall [OPTIONS] <APP_INSTALL>
# OPTIONS:
#   -2  :: pip2
#   -3  :: pip3
#   -u  :: update
# $1 = app name to install
pipinstall()
{
    local ltype="PIP"
    local pip="pip"
    local update=""
    local cmdinstall=""
    while [[ $# > 0 ]]; do
        case "$1" in
            -2)
                shift
                pip="pip2"
                ;;
            -3)
                shift
                pip="pip3"
                ;;
            -u)
                shift
                update="-U"
                ;;
            *)
                if [[ -z "${cmdinstall}" ]]; then
                    cmdinstall="${1}"
                else
                    loguj -e -t "${ltype}" "Unknown option? ($1)"
                    return 3
                fi
                shift
                ;;
        esac
    done

    if ! hash ${pip} 2>/dev/null; then
        loguj -e -t "${ltype}" "PIP not installed (${pip})"
        return 1
    fi


    if ${pip} -q show ${cmdinstall}; then # app is installed
        if [[ -z "${update}" ]]; then
            loguj -i -t "${ltype}" "App already installed: ${cmdinstall}"
            return 0
        fi
    fi
    loguj -p -i -t "${ltype}" "installing ${cmdinstall}..."
    ${__sudo} ${pip} install ${update} ${cmdinstall} \
        &&
        {
            loguj -l -t "${ltype}" "${cmdinstall}"
        } \
        ||
        {
            loguj -e -t "${ltype}" "Installing: ${__sudo} ${pip} install ${update} ${cmdinstall}"
            return 1
        }
}


